<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Steam Manifest/SHA1 Hash Checker</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <!-- Required external resources -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Roboto+Mono&display=swap"
        rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/hash-wasm@4.11.0/dist/sha1.umd.min.js"></script>
    <style>
        :root[data-theme="dark"] {
            --bg: #121212;
            --text: #e0e0e0;
            --border: #2f2f2f;
            --hover: #1f1f1f;
            --primary: #808080;
            --primary-dark: #666666;
            --primary-light: #a0a0a0;
            --metallic: linear-gradient(145deg, #1a1a1a, #121212);
            --metallic-hover: linear-gradient(145deg, #1f1f1f, #171717);
            --accent: #808080;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="blue"] {
            --bg: #1a1f2e;
            --text: #e0e6f2;
            --border: #2a3242;
            --hover: #2d344c;
            --primary: #4a74c9;
            --primary-dark: #385fa8;
            --primary-light: #6189d8;
            --metallic: linear-gradient(145deg, #2a3242, #1e2433);
            --metallic-hover: linear-gradient(145deg, #2d344c, #212737);
            --accent: #64b5f6;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="light"] {
            --bg: #ffffff;
            --text: #333333;
            --border: #dddddd;
            --hover: #f5f5f5;
            --primary: #555555;
            --primary-dark: #e0e0e0;
            --primary-light: #666666;
            --metallic: linear-gradient(145deg, #ffffff, #f8f8f8);
            --metallic-hover: linear-gradient(145deg, #f8f8f8, #f0f0f0);
            --accent: #555555;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
        }
        :root[data-theme="steam"] {
            --bg: #171a21;
            --text: #c6d4df;
            --border: #2a475e;
            --hover: #1b2838;
            --primary: #66c0f4;
            --primary-dark: #1b2838;
            --primary-light: #c7d5e0;
            --metallic: linear-gradient(145deg, #1b2838, #171a21);
            --metallic-hover: linear-gradient(145deg, #2a475e, #1b2838);
            --accent: #66c0f4;
            --success: #a4d007;
            --error: #cc3d3d;
            --warning: #ffa500;
        }
        :root[data-theme="synthwave"] {
            --bg: #1a1a2e;
            --text: #ff9ecd;
            --border: #342c56;
            --hover: #261d47;
            --primary: #f97bc1;
            --primary-dark: #fc2fa2;
            --primary-light: #ffb8e0;
            --metallic: linear-gradient(145deg, #2d1f54, #1a1a2e);
            --metallic-hover: linear-gradient(145deg, #342c56, #2d1f54);
            --accent: #3bfff9;
            --success: #72f1b8;
            --error: #ff3d81;
            --warning: #ffd319;
        }
        :root[data-theme="ocean"] {
            --bg: #0a192f;
            --text: #8892b0;
            --border: #1b3a57;
            --hover: #172a45;
            --primary: #64ffda;
            --primary-dark: #48d6b5;
            --primary-light: #7fffdf;
            --metallic: linear-gradient(145deg, #1b3a57, #0a192f);
            --metallic-hover: linear-gradient(145deg, #234668, #1b3a57);
            --accent: #00b4d8;
            --success: #2dd4bf;
            --error: #ef476f;
            --warning: #ffd60a;
        }
        :root[data-theme="forest"] {
            --bg: #1b2717;
            --text: #d8e2d5;
            --border: #2d3f24;
            --hover: #233019;
            --primary: #90b474;
            --primary-dark: #6a9547;
            --primary-light: #b1cc9a;
            --metallic: linear-gradient(145deg, #2d3f24, #1b2717);
            --metallic-hover: linear-gradient(145deg, #34492a, #2d3f24);
            --accent: #e9f5db;
            --success: #77dd77;
            --error: #ff6b6b;
            --warning: #ffd93d;
        }
        :root[data-theme="solarized"] {
            --bg: #002b36;
            --text: #839496;
            --border: #073642;
            --hover: #003847;
            --primary: #2aa198;
            --primary-dark: #1f7972;
            --primary-light: #35c8bd;
            --metallic: linear-gradient(145deg, #073642, #002b36);
            --metallic-hover: linear-gradient(145deg, #0b4653, #073642);
            --accent: #268bd2;
            --success: #859900;
            --error: #dc322f;
            --warning: #b58900;
        }
        :root {
            --radius: 12px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }
        /* Loading overlay styles */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 1000;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top: 3px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            color: var(--text);
            margin-top: 1rem;
            font-size: 1.2rem;
        }
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        body {
            font-family: 'Inter', system-ui, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            margin: 0;
            min-height: 100vh;
        }
        .container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 0 2rem;
            display: flex;
            flex-direction: column;
        }
        .header {
            background: var(--metallic);
            padding: 1.5rem 2rem;
            box-shadow: var(--shadow);
            margin-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .header h1 {
            margin: 0;
            font-size: 1.75rem;
            font-weight: 600;
            color: var(--primary-light);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        .header-controls {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        .theme-toggle {
            position: relative;
        }
        .theme-toggle select {
            appearance: none;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            font-size: 0.9rem;
        }
        .theme-toggle select:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .theme-toggle select option {
            background: var(--bg);
            color: var(--text);
            padding: 0.5rem;
        }
        .theme-toggle::after {
            content: "palette";
            font-family: "Material Icons";
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text);
        }
        .toggle-button {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
        }
        .toggle-button:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .toggle-button .material-icons {
            font-size: 1.25rem;
        }
        .dropzones {
            display: flex;
            gap: 1rem;
            margin-bottom: 2rem;
        }
        .dropzone {
            flex: 1;
            border: 2px dashed var(--primary);
            border-radius: var(--radius);
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            background: var(--metallic);
            transition: var(--transition);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            position: relative;
        }
        .dropzone input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        .dropzone textarea {
            position: relative;
            width: 100%;
            height: 100px;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem;
            border-radius: var(--radius);
            resize: none;
            font-family: 'Roboto Mono', monospace;
            font-size: 0.9rem;
            z-index: 1;
        }
        .dropzone textarea::-webkit-scrollbar {
            display: none;
        }
        .dropzone:hover,
        .dropzone.drag-over {
            background: var(--metallic-hover);
            border-color: var(--primary-light);
            transform: translateY(-2px);
        }
        .section {
            background: var(--metallic);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
        }
        .progress-container {
            margin: 1.5rem 0;
            background: var(--metallic);
            padding: 1.5rem;
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }
        .progress-bar {
            width: 100%;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary) 0%, var(--primary-light) 100%);
            width: 0;
            transition: width 0.3s ease;
        }
        .table-container {
            overflow-x: auto;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: var(--hover);
        }
        table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            table-layout: auto;
        }
        th {
            position: sticky;
            top: 0;
            background: var(--primary-dark);
            color: var(--text);
            border-bottom: 2px solid var(--border);
            padding: 0.75rem 1rem;
            font-weight: 500;
            text-align: left;
            white-space: nowrap;
        }
        .language-selector select option {
            background: var(--bg);
            color: var(--text);
            padding: 0.5rem;
        }
        [data-theme="light"] .language-selector select option {
            background: #ffffff;
            color: #333333;
        }
        [data-theme="light"] th {
            color: #333333 !important;
            background: #e0e0e0;
        }
        [data-theme="light"] .dropzone {
            border-color: #555555;
            color: #333333;
        }
        [data-theme="light"] .material-icons {
            color: #555555;
        }
        [data-theme="light"] .dropzone:hover,
        [data-theme="light"] .dropzone.drag-over {
            border-color: #333333;
            background: var(--hover);
        }
        td {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            white-space: nowrap;
        }
        .status {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .match {
            color: var(--success);
        }
        .mismatch {
            color: var(--error);
        }
        .pending {
            color: var(--warning);
        }
        .folder {
            color: var(--accent);
        }
        .hidden {
            display: none !important;
        }
        .error {
            color: var(--error);
            background: rgba(244, 67, 54, 0.1);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            border: 1px solid rgba(244, 67, 54, 0.2);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        @media (max-width: 768px) {
            .container {
                padding: 0 1rem;
            }
            .dropzones {
                flex-direction: column;
            }
            .dropzone {
                padding: 1.5rem;
            }
        }
        /* Language selector styles */
        .language-selector {
            margin-right: 1rem;
            position: relative;
        }
        .language-selector select {
            appearance: none;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 0.5rem 2.5rem 0.5rem 1rem;
            border-radius: var(--radius);
            cursor: pointer;
            transition: var(--transition);
            font-family: inherit;
            font-size: 0.9rem;
        }
        .language-selector select:hover {
            background: var(--metallic-hover);
            border-color: var(--primary);
        }
        .input-toggle {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
            z-index: 2;
            position: relative;
        }
        .toggle-label {
            font-size: 0.85rem;
            color: var(--text);
            opacity: 0.7;
        }
        .switch {
            position: relative;
            width: 50px;
            height: 26px;
        }
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--border);
            transition: 0.3s;
            border-radius: 26px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: var(--text);
            transition: 0.3s;
            border-radius: 50%;
        }
        .switch input:checked + .slider {
            background: var(--primary);
        }
        .switch input:checked + .slider:before {
            transform: translateX(24px);
        }
        .input-mode {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            width: 100%;
        }
        .input-mode.hidden {
            display: none;
        }
        #text-mode textarea {
            width: 100%;
            min-height: 120px;
            resize: vertical;
        }
        .language-selector::after {
            content: "language";
            font-family: "Material Icons";
            position: absolute;
            right: 0.75rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text);
        }
        th.sortable {
            cursor: pointer;
            user-select: none;
            transition: background 0.2s;
        }
        th.sortable:hover {
            background: var(--hover);
        }
        th.sortable::after {
            content: "unfold_more";
            font-family: "Material Icons";
            font-size: 1rem;
            margin-left: 0.25rem;
            vertical-align: middle;
            opacity: 0.5;
        }
        th.sortable.asc::after {
            content: "expand_less";
            opacity: 1;
        }
        th.sortable.desc::after {
            content: "expand_more";
            opacity: 1;
        }
        .search-container {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        .search-input {
            flex: 1;
            max-width: 400px;
            padding: 0.5rem 1rem;
            background: var(--metallic);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: var(--radius);
            font-family: inherit;
            font-size: 0.9rem;
            transition: var(--transition);
        }
        .search-input:focus {
            outline: none;
            border-color: var(--primary);
        }
        .search-input::placeholder {
            color: var(--text);
            opacity: 0.5;
        }
        .stats-bar {
            display: flex;
            gap: 1.5rem;
            padding: 1rem;
            background: var(--metallic);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .stat-item .material-icons {
            font-size: 1.25rem;
        }
        .stat-value {
            font-weight: 600;
            font-size: 1.1rem;
        }
        .stat-label {
            opacity: 0.7;
            font-size: 0.85rem;
        }
        .keyboard-hint {
            font-size: 0.75rem;
            opacity: 0.5;
            margin-left: 0.5rem;
        }
    </style>
</head>
<body>
    <div id="loading-overlay" class="loading-overlay hidden">
        <div class="loading-spinner"></div>
        <div class="loading-text" data-lang="ui.loading">Loading...</div>
    </div>
    <header class="header">
        <div class="header-content">
            <h1><span class="material-icons">verified</span> <span data-lang="app.title">Steam Manifest/SHA1
                    Checker</span></h1>
            <div class="header-controls">
                <div class="language-selector">
                    <select id="language-select">
                        <option value="en">English</option>
                        <option value="es">Español</option>
                        <option value="de">Deutsch</option>
                        <option value="fr">Français</option>
                        <option value="jp">日本語</option>
                        <option value="ru">Русский</option>
                        <option value="zh">中文</option>
                    </select>
                </div>
                <div class="theme-toggle">
                    <select id="theme-select">
                        <option value="dark">Dark Theme</option>
                        <option value="blue">Blue Theme</option>
                        <option value="light">Light Theme</option>
                        <option value="steam">Steam Theme</option>
                        <option value="synthwave">Synthwave Theme</option>
                        <option value="ocean">Ocean Theme</option>
                        <option value="forest">Forest Theme</option>
                        <option value="solarized">Solarized Theme</option>
                    </select>
                </div>
                <button id="folder-toggle" class="toggle-button">
                    <span class="material-icons">folder</span>
                    <span id="folder-toggle-text" data-lang="app.folderToggle.hide">Hide Folders</span>
                </button>
                <button id="download-sha1" class="toggle-button hidden">
                    <span class="material-icons">download</span>
                    <span data-lang="ui.downloadSha1">Export SHA1</span>
                </button>
            </div>
        </div>
    </header>
    <div class="container">
        <div class="dropzones">
            <div class="dropzone" id="drop-zone">
                <div class="input-toggle">
                    <span class="toggle-label" data-lang="dropzones.fileMode">File</span>
                    <label class="switch">
                        <input type="checkbox" id="input-mode-toggle">
                        <span class="slider"></span>
                    </label>
                    <span class="toggle-label" data-lang="dropzones.textMode">Text</span>
                </div>
                <div id="file-mode" class="input-mode">
                    <span class="material-icons">upload_file</span>
                    <span data-lang="dropzones.manifest">Drop Steam manifest or SHA1 file here</span>
                    <input type="file" id="file-input">
                </div>
                <div id="text-mode" class="input-mode hidden">
                    <span class="material-icons">edit_note</span>
                    <span data-lang="dropzones.textInput">Enter SHA1 hashes below</span>
                    <textarea id="raw-input" placeholder="SHA1 hashes here" data-lang-placeholder="dropzones.textareaPlaceholder"></textarea>
                </div>
            </div>
            <div class="dropzone" id="dir-zone">
                <span class="material-icons">folder_open</span>
                <span data-lang="dropzones.folder">Drop folder to verify here</span>
                <input type="file" id="dir-input" webkitdirectory directory>
            </div>
        </div>
        <div id="error" class="error hidden">
            <span class="material-icons">error</span>
            <span class="error-message"></span>
        </div>
        <div id="metadata" class="section hidden">
            <h2>
                <span class="material-icons">info</span>
                <span data-lang="fileInfo.title">File Info</span>
            </h2>
            <table>
                <tr>
                    <td data-lang="fileInfo.type">Type:</td>
                    <td id="file-type"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.depotId">Depot ID:</td>
                    <td id="depot-id"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.manifestId">Manifest ID:</td>
                    <td id="manifest-gid"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.creationDate">Creation Date:</td>
                    <td id="creation-time"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.totalFiles">Total Files:</td>
                    <td id="total-files"></td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.status">Status:</td>
                    <td id="completion-status" data-lang="status.notStarted">Not Started</td>
                </tr>
                <tr>
                    <td data-lang="fileInfo.totalSize">Total Size:</td>
                    <td id="total-size"></td>
                </tr>
            </table>
        </div>
        <div id="mismatches" class="section hidden">
            <h2>
                <span class="material-icons" style="color: var(--error);">warning</span>
                <span data-lang="mismatches.title">Mismatched Files</span>
            </h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th style="width: 40%" data-lang="mismatches.columns.filename">Filename</th>
                            <th style="width: 10%" data-lang="mismatches.columns.size">Size</th>
                            <th style="width: 25%" data-lang="mismatches.columns.expectedHash">Expected Hash</th>
                            <th style="width: 25%" data-lang="mismatches.columns.actualHash">Actual Hash</th>
                        </tr>
                    </thead>
                    <tbody id="mismatch-list"></tbody>
                </table>
            </div>
        </div>
        <div id="files" class="section hidden">
            <h2>
                <span class="material-icons">folder</span>
                <span data-lang="files.title">Files</span>
            </h2>
            <div id="stats-bar" class="stats-bar hidden">
                <div class="stat-item match">
                    <span class="material-icons">check_circle</span>
                    <span class="stat-value" id="stat-matches">0</span>
                    <span class="stat-label" data-lang="status.match">Match</span>
                </div>
                <div class="stat-item mismatch">
                    <span class="material-icons">error</span>
                    <span class="stat-value" id="stat-mismatches">0</span>
                    <span class="stat-label" data-lang="status.mismatch">Mismatch</span>
                </div>
                <div class="stat-item pending">
                    <span class="material-icons">pending</span>
                    <span class="stat-value" id="stat-pending">0</span>
                    <span class="stat-label" data-lang="status.pending">Pending</span>
                </div>
                <div class="stat-item folder">
                    <span class="material-icons">folder</span>
                    <span class="stat-value" id="stat-folders">0</span>
                    <span class="stat-label" data-lang="status.folder">Folder</span>
                </div>
            </div>
            <div class="search-container">
                <input type="text" id="file-search" class="search-input" placeholder="Search files..." data-lang-placeholder="ui.search">
                <button id="export-csv" class="toggle-button hidden">
                    <span class="material-icons">table_chart</span>
                    <span data-lang="ui.exportCsv">Export CSV</span>
                </button>
            </div>
            <div class="table-container">
                <table id="files-table">
                    <thead>
                        <tr>
                            <th style="width: 40%" class="sortable" data-sort="filename" data-lang="files.columns.filename">Filename</th>
                            <th style="width: 10%" class="sortable" data-sort="size" data-lang="files.columns.size">Size</th>
                            <th style="width: 25%" data-lang="files.columns.hash">Hash</th>
                            <th style="width: 25%" class="sortable" data-sort="status" data-lang="files.columns.status">Status</th>
                        </tr>
                    </thead>
                    <tbody id="file-list"></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        // Utility class for reading binary data
        class BinaryReader {
            constructor(buffer) {
                this.view = new DataView(buffer);
                this.offset = 0;
            }
            readUint32() {
                const value = this.view.getUint32(this.offset, true);
                this.offset += 4;
                return value;
            }
            readBytes(length) {
                const bytes = new Uint8Array(this.view.buffer, this.offset, length);
                this.offset += length;
                return bytes;
            }
            hasMore() {
                return this.offset < this.view.byteLength;
            }
        }
        // Language Manager class
        class LanguageManager {
            constructor(baseUrl) {
                this.baseUrl = baseUrl;
                this.currentLanguage = localStorage.getItem('language');
                // Auto-select language from browser UI language if unset
                if (!this.currentLanguage) {
                    const supportedLanguages = Array.from(document.getElementById('language-select').options).map(o => o.value);
                    this.currentLanguage = navigator.languages.map(l => l.substring(0, 2)).find(l => supportedLanguages.includes(l)) || 'en';
                }
                this.strings = null;
                this.fallbackStrings = {
                    // Default English strings in case language files can't be loaded
                    "app.title": "Steam Manifest/SHA1 Checker",
                    "fileInfo.types.steam": "Steam Manifest",
                    "fileInfo.types.sha1": "SHA1 File",
                    "status.match": "Match",
                    "status.mismatch": "Mismatch",
                    "status.pending": "Pending",
                    "status.folder": "Folder",
                    "status.notStarted": "Not Started",
                    "errors.loadManifest": "Load manifest or SHA1 file first",
                    "errors.noFiles": "No files selected",
                    "errors.invalidFormat": "Invalid file format:",
                    "errors.noValidHashes": "No valid SHA1 hashes found in file",
                    "errors.fileMissing": "File Missing",
                    "ui.loading": "Loading...",
                    "ui.downloadSha1": "Export SHA1",
                    "dropzones.fileMode": "File",
                    "dropzones.textMode": "Text",
                    "dropzones.textInput": "Enter SHA1 hashes below"
                };
            }
            // Initialize the language manager
            async init() {
                try {
                    await this.loadLanguage(this.currentLanguage);
                } catch (error) {
                    console.error('Failed to load language file, using fallback strings');
                    this.strings = this.fallbackStrings;
                }
                this.updateUI();
                this.initLanguageSelector();
            }
            // Load language strings from URL
            async loadLanguage(lang) {
                try {
                    const response = await fetch(`${this.baseUrl}/languages/${lang}.json`);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    this.strings = await response.json();
                    this.currentLanguage = lang;
                    localStorage.setItem('language', lang);
                } catch (error) {
                    console.error(`Failed to load language '${lang}':`, error);
                    this.strings = this.fallbackStrings;
                    if (lang !== 'en') {
                        return this.loadLanguage('en');
                    }
                    throw error;
                }
            }
            // Get a string by its path
            getString(path) {
                if (!this.strings) return this.fallbackStrings[path] || path;
                return path.split('.').reduce((obj, key) => obj?.[key], this.strings) ||
                    this.fallbackStrings[path] || path;
            }
            // Update UI with current language strings
            updateUI() {
                // Update title
                document.title = this.getString('app.title');
                // Update all elements with data-lang attribute
                document.querySelectorAll('[data-lang]').forEach(element => {
                    const key = element.getAttribute('data-lang');
                    element.textContent = this.getString(key);
                });
                // data-lang-placeholder
                document.querySelectorAll('[data-lang-placeholder]').forEach(element => {
                    const key = element.getAttribute('data-lang-placeholder');
                    element.setAttribute('placeholder', this.getString(key));
                });
                // If there's a manifest loaded, refresh it
                if (window.currentManifest) {
                    displayManifest(window.currentManifest);
                }
            }
            // Add language selector to the UI
            initLanguageSelector() {
                const select = document.getElementById('language-select');
                select.value = this.currentLanguage;
                select.addEventListener('change', (e) => {
                    this.loadLanguage(e.target.value).then(() => this.updateUI());
                });
            }
        }
        // Progress Manager class to handle the progress bar
        const ProgressManager = {
            container: null,
            lastUpdate: 0,
            create() {
                this.lastUpdate = 0;
                this.container = document.createElement('div');
                this.container.className = 'progress-container';
                this.container.innerHTML = `
                    <div class="progress-bar">
                        <div class="progress-fill"></div>
                    </div>
                    <div class="progress-stats">
                        <div class="progress-text">
                            <span class="material-icons">task_alt</span>
                            <span>Matched: 
                                <span id="matched-count">0</span>/
                                <span id="total-checkable">0</span>
                            </span>
                            <span class="speed-info">Speed: 
                                <span id="hash-speed">0 MB/s</span>
                            </span>
                        </div>
                    </div>
                `;
                document.querySelector('.container').insertBefore(
                    this.container,
                    document.getElementById('files')
                );
                return this.container;
            },
            update(stats, force = false) {
                if (!this.container) return;
                const now = Date.now();
                if (!force && now - this.lastUpdate < 100) return;
                this.lastUpdate = now;
                const progress = (stats.matches / stats.total) * 100;
                this.container.querySelector('.progress-fill').style.width = `${progress}%`;
                this.container.querySelector('#matched-count').textContent = stats.matches;
                this.container.querySelector('#total-checkable').textContent = stats.total;
                this.container.querySelector('#hash-speed').textContent = stats.speed;
            },
            remove() {
                if (this.container) {
                    this.container.remove();
                    this.container = null;
                }
            }
        };
        // Steam Manifest Parser Class
        class Manifest {
            static PAYLOAD_MAGIC = 0x71F617D0;
            static METADATA_MAGIC = 0x1F4812BE;
            static ENDOFMANIFEST_MAGIC = 0x32C415AB;
            static async fromBuffer(buffer) {
                const reader = new BinaryReader(buffer);
                const manifest = {
                    Files: [],
                    DepotID: 0,
                    ManifestGID: 0,
                    CreationTime: new Date(),
                    TotalSize: 0
                };
                while (reader.hasMore()) {
                    const magic = reader.readUint32();
                    if (magic === this.ENDOFMANIFEST_MAGIC) break;
                    const length = reader.readUint32();
                    const data = reader.readBytes(length);
                    if (magic === this.PAYLOAD_MAGIC) {
                        this.parsePayload(data, manifest);
                    } else if (magic === this.METADATA_MAGIC) {
                        this.parseMetadata(data, manifest);
                    }
                }
                return manifest;
            }
            static parseVarint(bytes, offset = 0) {
                let value = 0n;
                let shift = 0n;
                let index = offset;
                while (index < bytes.length) {
                    const byte = bytes[index++];
                    value |= BigInt(byte & 0x7F) << shift;
                    if ((byte & 0x80) === 0) break;
                    shift += 7n;
                }
                return [value, index - offset];
            }
            static parseProtoField(bytes, offset) {
                const [tag, tagLen] = this.parseVarint(bytes, offset);
                const fieldNum = Number(tag >> 3n);
                const wireType = Number(tag & 0x07n);
                offset += tagLen;
                let value, valueLen;
                if (wireType === 0) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                } else if (wireType === 2) {
                    [value, valueLen] = this.parseVarint(bytes, offset);
                    const strLen = Number(value);
                    value = bytes.slice(offset + valueLen, offset + valueLen + strLen);
                    valueLen += strLen;
                }
                return {
                    fieldNum,
                    value,
                    bytesRead: tagLen + valueLen
                };
            }
            static parsePayload(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    if (field.fieldNum === 1) {
                        const mapping = field.value;
                        let mappingOffset = 0;
                        const fileInfo = {
                            FileName: '',
                            FileHash: new Uint8Array(),
                            TotalSize: 0
                        };
                        while (mappingOffset < mapping.length) {
                            const mappingField = this.parseProtoField(mapping, mappingOffset);
                            mappingOffset += mappingField.bytesRead;
                            switch (mappingField.fieldNum) {
                                case 1:
                                    fileInfo.FileName = new TextDecoder().decode(mappingField.value);
                                    break;
                                case 2:
                                    fileInfo.TotalSize = Number(mappingField.value);
                                    break;
                                case 5:
                                    fileInfo.FileHash = mappingField.value;
                                    break;
                            }
                        }
                        if (fileInfo.FileName) manifest.Files.push(fileInfo);
                    }
                }
            }
            static parseMetadata(data, manifest) {
                let offset = 0;
                while (offset < data.length) {
                    const field = this.parseProtoField(data, offset);
                    offset += field.bytesRead;
                    switch (field.fieldNum) {
                        case 1:
                            manifest.DepotID = Number(field.value);
                            break;
                        case 2:
                            manifest.ManifestGID = field.value;
                            break;
                        case 3:
                            manifest.CreationTime = new Date(Number(field.value) * 1000);
                            break;
                        case 5:
                            manifest.TotalSize = Number(field.value);
                            break;
                    }
                }
            }
        }
        // File Processing Utilities
        const FileProcessor = {
            async readChunk(file, offset, length) {
                return new Promise(resolve => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.readAsArrayBuffer(file.slice(offset, offset + length));
                });
            },
            getRelativePath(file) {
                let relativePath = file.relativePath || file.webkitRelativePath;
                if (!relativePath) {
                    return file.name;
                }
                relativePath = relativePath.replace(/\\/g, '/');
                const pathParts = relativePath.split('/');
                return pathParts.length > 1 ? pathParts.slice(1).join('/') : file.name;
            },
            createMismatchRow(fileName, fileSize, expectedHash, actualHash) {
                const mismatchRow = document.createElement('tr');
                mismatchRow.innerHTML = `
                    <td>${utils.escapeHtml(fileName)}</td>
                    <td>${utils.escapeHtml(fileSize)}</td>
                    <td class="file-hash">${utils.escapeHtml(expectedHash)}</td>
                    <td class="file-hash">${utils.escapeHtml(actualHash)}</td>
                `;
                return mismatchRow;
            }
        };
        // General Utility Functions
        const utils = {
            escapeHtmlDiv: document.createElement('div'),
            escapeHtml(str) {
                this.escapeHtmlDiv.textContent = str;
                return this.escapeHtmlDiv.innerHTML;
            },
            fileMap: null,
            rowMap: null,
            stats: { matches: 0, mismatches: 0, folders: 0, total: 0 },
            sortState: { column: null, direction: 'asc' },
            searchTerm: '',
            buildFileMap() {
                this.fileMap = new Map();
                if (!window.currentManifest?.Files) return;
                for (const file of window.currentManifest.Files) {
                    const normalized = this.normalizePath(file.FileName);
                    this.fileMap.set(normalized, file);
                    const parts = normalized.split('/');
                    const baseName = parts[parts.length - 1];
                    if (!this.fileMap.has('base:' + baseName)) {
                        this.fileMap.set('base:' + baseName, []);
                    }
                    this.fileMap.get('base:' + baseName).push(file);
                }
            },
            formatSize(bytes) {
                const units = ['B', 'KB', 'MB', 'GB'];
                let value = Number(bytes);
                let unit = 0;
                while (value >= 1024 && unit < units.length - 1) {
                    value /= 1024;
                    unit++;
                }
                return `${value.toFixed(1)} ${units[unit]}`;
            },
            formatHash(hash) {
                return Array.from(hash)
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join('');
            },
            formatDate(date) {
                return new Intl.DateTimeFormat('default', {
                    year: 'numeric',
                    month: 'short',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                }).format(date);
            },
            isFolder(hash) {
                return typeof hash === 'string' ?
                    hash === '0000000000000000000000000000000000000000' :
                    this.formatHash(hash) === '0000000000000000000000000000000000000000';
            },
            normalizePath(path) {
                path = path.replace(/\\/g, '/');
                path = path.replace(/^\/+|\/+$/g, '');
                path = path.replace(/^\.\//, '');
                path = path.replace(/\/+/g, '/');
                return path.toLowerCase();
            },
            findMatchingFile(fileName) {
                if (!this.fileMap) this.buildFileMap();
                if (!this.fileMap || this.fileMap.size === 0) return null;
                const normalizedInput = this.normalizePath(fileName);
                const exactMatch = this.fileMap.get(normalizedInput);
                if (exactMatch) return exactMatch;
                const inputParts = normalizedInput.split('/');
                const inputBaseName = inputParts[inputParts.length - 1];
                const candidates = this.fileMap.get('base:' + inputBaseName);
                if (!candidates || candidates.length === 0) return null;
                if (candidates.length === 1) return candidates[0];
                let bestMatch = null;
                let bestScore = -1;
                for (const candidate of candidates) {
                    const manifestPath = this.normalizePath(candidate.FileName);
                    const manifestParts = manifestPath.split('/');
                    let score = 0;
                    const minLen = Math.min(inputParts.length, manifestParts.length);
                    for (let i = 1; i <= minLen; i++) {
                        if (inputParts[inputParts.length - i] === manifestParts[manifestParts.length - i]) {
                            score += 10;
                        } else {
                            break;
                        }
                    }
                    if (inputParts.length === manifestParts.length && score === minLen * 10) {
                        score += 1000;
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = candidate;
                    }
                }
                return bestMatch;
            },
            parseSHA1File(content) {
                const lines = content.split(/[\r\n]+/).filter(line => line.trim());
                const files = [];
                const seenFiles = new Set();
                lines.forEach((line, index) => {
                    line = line.trim().replace(/^\uFEFF/, '');
                    if (!line || line.startsWith('#')) return;
                    try {
                        let hash, fileName, fileSize;
                        let match = line.match(/([a-fA-F0-9]{40})\s+[*]?(.+)/i);
                        if (match) {
                            [, hash, fileName] = match;
                        } else {
                            match = line.match(/SHA1\((.+?)\)[= ]+([a-fA-F0-9]{40})/i);
                            if (match) {
                                [, fileName, hash] = match;
                            } else {
                                // SteamDB format
                                match = line.match(/(.+?)\t([a-fA-F0-9*]{23})\t(\d+)/i);
                                if (match) {
                                    [, fileName, hash, fileSize] = match;
                                } else {
                                    match = line.match(/([a-fA-F0-9]{40})/i);
                                    if (match) {
                                        hash = match[1];
                                        fileName = line.replace(hash, '').trim();
                                        if (!fileName) fileName = `file_${index}`;
                                    }
                                }
                            }
                        }
                        if (hash && fileName) {
                            fileName = fileName.trim().replace(/\\/g, '/');
                            const fileKey = `${fileName}|${hash}`;
                            if (!seenFiles.has(fileKey)) {
                                seenFiles.add(fileKey);
                                files.push({
                                    FileName: fileName,
                                    FileHash: hash.toLowerCase(),
                                    TotalSize: fileSize ? Number(fileSize) : 0
                                });
                            }
                        }
                    } catch (err) {
                        console.warn(`Failed to parse line ${index}:`, err);
                    }
                });
                if (files.length === 0) {
                    throw new Error(window.languageManager.getString('errors.noValidHashes'));
                }
                return {
                    Files: files,
                    DepotID: 'SHA1 File',
                    ManifestGID: 'N/A',
                    CreationTime: new Date(),
                    TotalSize: files.some(e => e.TotalSize > 0) ? files.reduce((a, c) => a + c.TotalSize, 0) : 0,
                    isSHA1File: true
                };
            },
            markPendingAsMissing() {
                const mismatchList = document.getElementById('mismatch-list');
                const pendingStatuses = document.querySelectorAll('#file-list tr .status.pending');
                pendingStatuses.forEach(status => {
                    this.updateStatus(status, 'mismatch');
                    this.stats.mismatches++;
                    const row = status.closest('tr');
                    const fileName = row.children[0].textContent;
                    const fileSize = row.children[1].textContent;
                    const expectedHash = row.children[2].textContent;
                    const mismatchRow = FileProcessor.createMismatchRow(
                        fileName,
                        fileSize,
                        expectedHash,
                        window.languageManager.getString('errors.fileMissing')
                    );
                    mismatchList.appendChild(mismatchRow);
                });
                if (mismatchList.children.length > 0) {
                    document.getElementById('mismatches').classList.remove('hidden');
                }
            },
            showError(message) {
                const error = document.getElementById('error');
                error.innerHTML = `
                    <span class="material-icons">error</span>
                    <span class="error-message">${this.escapeHtml(message)}</span>
                `;
                error.classList.remove('hidden');
                document.getElementById('metadata').classList.add('hidden');
                document.getElementById('files').classList.add('hidden');
                document.getElementById('mismatches').classList.add('hidden');
            },
            hideError() {
                document.getElementById('error').classList.add('hidden');
            },
            updateStatus(element, status) {
                const icons = {
                    match: 'check_circle',
                    mismatch: 'error',
                    pending: 'pending',
                    folder: 'folder'
                };
                const statusText = window.languageManager.getString(`status.${status}`);
                element.innerHTML = `
                    <span class="material-icons">${icons[status]}</span>
                    ${statusText}
                `;
                element.className = `status ${status}`;
            },
            sortTable(column) {
                const fileList = document.getElementById('file-list');
                const rows = Array.from(fileList.querySelectorAll('tr'));
                if (this.sortState.column === column) {
                    this.sortState.direction = this.sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    this.sortState.column = column;
                    this.sortState.direction = 'asc';
                }
                document.querySelectorAll('#files-table th.sortable').forEach(th => {
                    th.classList.remove('asc', 'desc');
                    if (th.dataset.sort === column) {
                        th.classList.add(this.sortState.direction);
                    }
                });
                const statusOrder = { match: 0, folder: 1, pending: 2, mismatch: 3 };
                rows.sort((a, b) => {
                    let aVal, bVal;
                    if (column === 'filename') {
                        aVal = a.children[0].textContent.toLowerCase();
                        bVal = b.children[0].textContent.toLowerCase();
                    } else if (column === 'size') {
                        aVal = this.parseSizeToBytes(a.children[1].textContent);
                        bVal = this.parseSizeToBytes(b.children[1].textContent);
                    } else if (column === 'status') {
                        const aStatus = a.querySelector('.status')?.classList[1] || 'pending';
                        const bStatus = b.querySelector('.status')?.classList[1] || 'pending';
                        aVal = statusOrder[aStatus] ?? 4;
                        bVal = statusOrder[bStatus] ?? 4;
                    }
                    if (aVal < bVal) return this.sortState.direction === 'asc' ? -1 : 1;
                    if (aVal > bVal) return this.sortState.direction === 'asc' ? 1 : -1;
                    return 0;
                });
                rows.forEach(row => fileList.appendChild(row));
            },
            parseSizeToBytes(sizeStr) {
                if (sizeStr === window.languageManager.getString('status.folder')) return -1;
                const match = sizeStr.match(/([\d.]+)\s*(B|KB|MB|GB)/i);
                if (!match) return 0;
                const value = parseFloat(match[1]);
                const unit = match[2].toUpperCase();
                const multipliers = { B: 1, KB: 1024, MB: 1024 * 1024, GB: 1024 * 1024 * 1024 };
                return value * (multipliers[unit] || 1);
            },
            filterFiles(searchTerm) {
                this.searchTerm = searchTerm.toLowerCase();
                const rows = document.querySelectorAll('#file-list tr');
                rows.forEach(row => {
                    const filename = row.children[0].textContent.toLowerCase();
                    const hash = row.children[2].textContent.toLowerCase();
                    const matches = filename.includes(this.searchTerm) || hash.includes(this.searchTerm);
                    row.style.display = matches ? '' : 'none';
                });
            },
            updateStatsBar() {
                const statsBar = document.getElementById('stats-bar');
                const pending = this.stats.total - this.stats.folders - this.stats.matches - this.stats.mismatches;
                document.getElementById('stat-matches').textContent = this.stats.matches;
                document.getElementById('stat-mismatches').textContent = this.stats.mismatches;
                document.getElementById('stat-pending').textContent = Math.max(0, pending);
                document.getElementById('stat-folders').textContent = this.stats.folders;
                if (this.stats.matches > 0 || this.stats.mismatches > 0) {
                    statsBar.classList.remove('hidden');
                }
            },
            exportCSV() {
                if (!window.currentManifest?.Files) return;
                const rows = [['Filename', 'Size', 'Hash', 'Status']];
                const fileList = document.querySelectorAll('#file-list tr');
                fileList.forEach(row => {
                    if (row.style.display === 'none') return;
                    const filename = row.children[0].textContent;
                    const size = row.children[1].textContent;
                    const hash = row.children[2].textContent;
                    const statusEl = row.querySelector('.status');
                    const status = statusEl ? statusEl.textContent.trim() : '';
                    rows.push([`"${filename.replace(/"/g, '""')}"`, size, hash, status]);
                });
                const csv = rows.map(r => r.join(',')).join('\n');
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const manifestName = window.currentManifest.isSHA1File ? 'export' :
                    `${window.currentManifest.DepotID}_${window.currentManifest.ManifestGID}`;
                a.download = `${manifestName}_files.csv`;
                a.click();
                URL.revokeObjectURL(url);
            }
        };
        // Main Functions
        async function handleDirectory(files) {
            if (!files.length || !window.currentManifest) {
                utils.showError(!window.currentManifest ?
                    window.languageManager.getString('errors.loadManifest') :
                    window.languageManager.getString('errors.noFiles'));
                return;
            }
            utils.hideError();
            const progress = ProgressManager.create();
            const sha1 = await hashwasm.createSHA1();
            let processedBytes = 0;
            let startTime = Date.now();
            try {
                for (const file of files) {
                    sha1.init();
                    if (file.stream) {
                        const reader = file.stream().getReader();
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            sha1.update(value);
                            processedBytes += value.length;
                            ProgressManager.update({
                                matches: utils.stats.matches,
                                total: utils.stats.total - utils.stats.folders,
                                speed: utils.formatSize(processedBytes / ((Date.now() - startTime) / 1000)) + '/s'
                            });
                        }
                    } else {
                        let chunkOffset = 0;
                        while (chunkOffset < file.size) {
                            const chunkSize = Math.min(16 * 1024 * 1024, file.size - chunkOffset);
                            const chunk = await FileProcessor.readChunk(file, chunkOffset, chunkSize);
                            sha1.update(new Uint8Array(chunk));
                            processedBytes += chunkSize;
                            chunkOffset += chunkSize;
                            ProgressManager.update({
                                matches: utils.stats.matches,
                                total: utils.stats.total - utils.stats.folders,
                                speed: utils.formatSize(processedBytes / ((Date.now() - startTime) / 1000)) + '/s'
                            });
                        }
                    }
                    const relativePath = FileProcessor.getRelativePath(file);
                    updateFileStatuses(sha1.digest(), file.size, relativePath);
                }
            } catch (error) {
                utils.showError(window.languageManager.getString('errors.processingError') + ' ' + error.message);
            } finally {
                utils.markPendingAsMissing();
                const totalCheckableFiles = utils.stats.total - utils.stats.folders;
                if (utils.stats.matches === totalCheckableFiles) {
                    ProgressManager.remove();
                }
            }
        }
        async function handleManifestFile(file) {
            const resolver = async (e = null) => {
                try {
                    utils.hideError();
                    let uploadedManifest;
                    const content = e === null ? file : new TextDecoder().decode(e.target.result);
                    if (e === null ||
                        file.name.toLowerCase().endsWith('.sha1') ||
                        file.type === 'text/plain' ||
                        content.includes('sha1') ||
                        content.match(/[a-fA-F0-9]{40}/i)) {
                        try {
                            uploadedManifest = utils.parseSHA1File(content);
                        } catch (sha1Err) {
                            if (e === null) {
                                throw sha1Err;
                            }
                            uploadedManifest = await Manifest.fromBuffer(e.target.result);
                        }
                    } else {
                        uploadedManifest = await Manifest.fromBuffer(e.target.result);
                    }
                    displayManifest(uploadedManifest);
                } catch (err) {
                    console.error('Error parsing file:', err);
                    utils.showError(window.languageManager.getString('errors.invalidFormat') + ' ' + err.message);
                }
            };
            if (typeof file === "string") {
                resolver();
                return;
            }
            const reader = new FileReader();
            reader.onload = resolver;
            reader.readAsArrayBuffer(file);
        }
        function updateFileStatuses(hash, fileSize, fileName) {
            const manifestFile = utils.findMatchingFile(fileName);
            if (!manifestFile || utils.isFolder(manifestFile.FileHash)) return;
            const expectedHash = window.currentManifest.isSHA1File ?
                manifestFile.FileHash :
                utils.formatHash(manifestFile.FileHash);
            const actualHash = typeof hash === 'string' ? hash : utils.formatHash(hash);
            const matchStatus = (() => {
                // Check file size (only if manifest has size info)
                if (manifestFile.TotalSize > 0 && manifestFile.TotalSize !== fileSize) {
                    return 'mismatch';
                }
                // Check SHA1
                const actualHashL = actualHash.toLowerCase();
                if (expectedHash.includes('*')) {
                    return expectedHash.substring(0, 10) === actualHashL.substring(0, 10) &&
                        expectedHash.substring(13) === actualHashL.substring(actualHashL.length - 10) ? 'match' : 'mismatch';
                } else {
                    return expectedHash.toLowerCase() === actualHashL ? 'match' : 'mismatch';
                }
            })();
            const row = utils.rowMap.get(manifestFile.FileName);
            if (row) {
                utils.updateStatus(row.querySelector('.status'), matchStatus);
                if (matchStatus === 'match') {
                    utils.stats.matches++;
                } else {
                    utils.stats.mismatches++;
                    const mismatchList = document.getElementById('mismatch-list');
                    const mismatchRow = FileProcessor.createMismatchRow(
                        manifestFile.FileName,
                        row.children[1].textContent,
                        expectedHash,
                        actualHash
                    );
                    mismatchList.appendChild(mismatchRow);
                    document.getElementById('mismatches').classList.remove('hidden');
                }
            }
            updateCompletionStatus();
        }
        function updateCompletionStatus() {
            const totalCheckableFiles = utils.stats.total - utils.stats.folders;
            let statusType = 'pending';
            if (utils.stats.matches > 0) {
                if (utils.stats.matches === totalCheckableFiles) {
                    statusType = utils.stats.mismatches === 0 ? 'match' : 'mismatch';
                } else if (utils.stats.mismatches > 0) {
                    statusType = 'mismatch';
                }
            }
            utils.updateStatus(document.getElementById('completion-status'), statusType);
            utils.updateStatsBar();
        }
        function displayManifest(manifest) {
            try {
                window.currentManifest = manifest;
                utils.fileMap = null;
                utils.rowMap = new Map();
                utils.stats = { matches: 0, mismatches: 0, folders: 0, total: 0 };
                document.getElementById('mismatch-list').innerHTML = '';
                document.getElementById('mismatches').classList.add('hidden');
                document.getElementById('file-type').textContent = manifest.isSHA1File ?
                    window.languageManager.getString('fileInfo.types.sha1') :
                    window.languageManager.getString('fileInfo.types.steam');
                document.getElementById('depot-id').textContent = manifest.DepotID;
                document.getElementById('manifest-gid').textContent = manifest.ManifestGID?.toString();
                document.getElementById('creation-time').textContent = utils.formatDate(manifest.CreationTime);
                // Get the current state of the folder toggle
                const hideFolders = localStorage.getItem('hideFolders') === 'true';
                // Filter files based on the toggle state
                const filteredFiles = manifest.Files.filter(file =>
                    hideFolders ? !utils.isFolder(file.FileHash) : true
                );
                const fileList = document.getElementById('file-list');
                fileList.innerHTML = '';
                filteredFiles.forEach(file => {
                    const row = document.createElement('tr');
                    const isFolder = utils.isFolder(file.FileHash);
                    const escapedFileName = utils.escapeHtml(file.FileName);
                    const escapedHash = utils.escapeHtml(manifest.isSHA1File ? file.FileHash : utils.formatHash(file.FileHash));
                    row.innerHTML = `
                        <td>${escapedFileName}</td>
                        <td>${isFolder ? window.languageManager.getString('status.folder') : utils.formatSize(file.TotalSize)}</td>
                        <td class="file-hash">${isFolder ? window.languageManager.getString('status.folder') : escapedHash}</td>
                        <td class="status ${isFolder ? 'folder' : 'pending'}">
                            <span class="material-icons">${isFolder ? 'folder' : 'pending'}</span>
                            ${isFolder ? window.languageManager.getString('status.folder') : window.languageManager.getString('status.pending')}
                        </td>
                    `;
                    fileList.appendChild(row);
                    utils.rowMap.set(file.FileName, row);
                    if (isFolder) {
                        utils.stats.folders++;
                    }
                    utils.stats.total++;
                });
                // Only count non-folder files for the totals
                const nonFolderFiles = manifest.Files.filter(file => !utils.isFolder(file.FileHash));
                document.getElementById('total-files').textContent = nonFolderFiles.length;
                document.getElementById('total-size').textContent = utils.formatSize(nonFolderFiles.reduce((sum, file) =>
                    sum + Number(file.TotalSize), 0));
                utils.updateStatus(document.getElementById('completion-status'), 'pending');
                document.getElementById('metadata').classList.remove('hidden');
                document.getElementById('files').classList.remove('hidden');
                document.getElementById('download-sha1').classList.remove('hidden');
                document.getElementById('export-csv').classList.remove('hidden');
                document.getElementById('stats-bar').classList.add('hidden');
                document.getElementById('file-search').value = '';
                utils.searchTerm = '';
                utils.sortState = { column: null, direction: 'asc' };
                document.querySelectorAll('#files-table th.sortable').forEach(th => {
                    th.classList.remove('asc', 'desc');
                });
                utils.hideError();
            } catch (err) {
                console.error('Error:', err);
                utils.showError(err.message);
            }
        }
        function initThemes() {
            const themeSelect = document.getElementById('theme-select');
            const savedTheme = localStorage.getItem('theme') || 'steam';
            for (const option of themeSelect.options) {
                option.setAttribute('data-lang', `app.themes.${option.value}`);
            }
            document.documentElement.setAttribute('data-theme', savedTheme);
            themeSelect.value = savedTheme;
            themeSelect.addEventListener('change', (e) => {
                const newTheme = e.target.value;
                document.documentElement.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
            });
        }
        function initializeUI() {
            // File upload handlers
            document.getElementById('file-input').addEventListener('change', (e) => {
                if (e.target.files[0]) handleManifestFile(e.target.files[0]);
            });
            document.getElementById('dir-input').addEventListener('change', (e) => {
                if (e.target.files.length) handleDirectory(Array.from(e.target.files));
            });
            // Input mode toggle
            const inputModeToggle = document.getElementById('input-mode-toggle');
            const fileMode = document.getElementById('file-mode');
            const textMode = document.getElementById('text-mode');
            inputModeToggle.addEventListener('change', (e) => {
                if (e.target.checked) {
                    fileMode.classList.add('hidden');
                    textMode.classList.remove('hidden');
                } else {
                    fileMode.classList.remove('hidden');
                    textMode.classList.add('hidden');
                }
            });
            // Raw input handler
            document.getElementById('raw-input').addEventListener('change', (e) => {
                if (typeof e.target.value === 'string' && e.target.value !== '') handleManifestFile(e.target.value);
            });
            // Initialize download SHA1 button
            document.getElementById('download-sha1').addEventListener('click', () => {
                if (!window.currentManifest?.Files) return;
                const lines = window.currentManifest.Files
                    .filter(f => !utils.isFolder(f.FileHash))
                    .map(f => {
                        const hash = typeof f.FileHash === 'string' ? f.FileHash : utils.formatHash(f.FileHash);
                        return `${hash} *${f.FileName.replace(/\\/g, '/')}`;
                    });
                const content = lines.join('\n');
                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const manifestName = window.currentManifest.isSHA1File ? 'export' :
                    `${window.currentManifest.DepotID}_${window.currentManifest.ManifestGID}`;
                a.download = `${manifestName}.sha1`;
                a.click();
                URL.revokeObjectURL(url);
            });
            // Initialize folder toggle
            const folderToggle = document.getElementById('folder-toggle');
            const folderToggleText = document.getElementById('folder-toggle-text');
            let hideFolders = localStorage.getItem('hideFolders') === 'true';
            folderToggleText.textContent = window.languageManager.getString(`app.folderToggle.${hideFolders ? 'show' : 'hide'}`);
            folderToggle.addEventListener('click', () => {
                hideFolders = !hideFolders;
                localStorage.setItem('hideFolders', hideFolders);
                folderToggleText.textContent = window.languageManager.getString(`app.folderToggle.${hideFolders ? 'show' : 'hide'}`);
                if (window.currentManifest) {
                    displayManifest(window.currentManifest);
                }
            });
            // Initialize sortable column headers
            document.querySelectorAll('#files-table th.sortable').forEach(th => {
                th.addEventListener('click', () => {
                    utils.sortTable(th.dataset.sort);
                });
            });
            // Initialize file search
            const fileSearch = document.getElementById('file-search');
            let searchTimeout;
            fileSearch.addEventListener('input', (e) => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => {
                    utils.filterFiles(e.target.value);
                }, 150);
            });
            // Initialize CSV export
            document.getElementById('export-csv').addEventListener('click', () => {
                utils.exportCSV();
            });
            // Initialize keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'f' || e.key === 'F') {
                        e.preventDefault();
                        fileSearch.focus();
                    } else if (e.key === 'e' || e.key === 'E') {
                        e.preventDefault();
                        if (window.currentManifest) utils.exportCSV();
                    } else if (e.key === 's' || e.key === 'S') {
                        e.preventDefault();
                        if (window.currentManifest) document.getElementById('download-sha1').click();
                    }
                } else if (e.key === 'Escape') {
                    fileSearch.value = '';
                    utils.filterFiles('');
                    fileSearch.blur();
                }
            });
            // Initialize drag and drop for both zones
            ['drop-zone', 'dir-zone'].forEach(id => {
                const element = document.getElementById(id);
                element.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.add('drag-over');
                });
                element.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                });
                element.addEventListener('drop', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    element.classList.remove('drag-over');
                    if (id === 'drop-zone' && e.dataTransfer.files[0]) {
                        handleManifestFile(e.dataTransfer.files[0]);
                    } else if (id === 'dir-zone') {
                        const items = e.dataTransfer.items;
                        const files = [];
                        async function getAllFiles(entry) {
                            if (entry.isFile) {
                                return new Promise((resolve) => {
                                    entry.file(file => {
                                        const pathParts = entry.fullPath.split('/');
                                        file.relativePath = "/" + pathParts.slice(2).join('/');
                                        files.push(file);
                                        resolve();
                                    }, (err) => {
                                        console.warn(`Failed to read file: ${entry.fullPath}`, err);
                                        resolve();
                                    });
                                });
                            } 
                            else if (entry.isDirectory) {
                                const reader = entry.createReader();
                                const entries = [];
                                
                                const readBatch = () => new Promise((resolve, reject) => {
                                    reader.readEntries(resolve, reject);
                                });

                                try {
                                    let batch;
                                    do {
                                        batch = await readBatch();
                                        entries.push(...batch);
                                    } while (batch.length > 0);
                                    
                                    const promises = entries.map(entry => getAllFiles(entry));
                                    await Promise.all(promises);
                                } catch (err) {
                                    console.warn(`Error reading directory: ${entry.fullPath}`, err);
                                }
                            }
                        }
                        const promises = [];
                        for (const item of items) {
                            if (item.kind === 'file') {
                                const entry = item.webkitGetAsEntry();
                                if (entry) {
                                    promises.push(getAllFiles(entry));
                                }
                            }
                        }
                        await Promise.all(promises);
                        if (files.length > 0) {
                            handleDirectory(files);
                        }
                    }
                });
            });
        }
        // Initialize and start the application
        async function init() {
            initThemes();
            const languageManager = new LanguageManager('https://raw.githubusercontent.com/MorrenusGames/steam-manifest-hash-checker-HTML/main');
            await languageManager.init();
            window.languageManager = languageManager;
            initializeUI();
        }
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>